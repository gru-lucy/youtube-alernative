const{ipcRenderer:ipcRenderer}=require("electron"),{existsSync:existsSync,writeFileSync:writeFileSync,readFileSync:readFileSync,mkdirSync:mkdirSync,cpSync:cpSync,statSync:statSync,rmSync:rmSync}=require("fs"),{resolve:resolve,dirname:dirname}=require("path"),WebTorrent=require("webtorrent");import utils from"./webtorrent-utils.js";const{torrentToJson:torrentToJson}=utils,downloadThreshold=3e7,maxWaitTime=6e4,maxTask=5;let maxPreload=20;if("string"===typeof localStorage.getItem("library-max-preload")){const e=Number(localStorage.getItem("library-max-preload"));isNaN(e)||(maxPreload=e)}let storePath="";const preloadClient=new WebTorrent({maxConns:5,downloadLimit:3e6,uploadLimit:3e5}),preloadTasks=new Map,taskQueue=[],previous=[],failures=[];global.preload={client:preloadClient,tasks:preloadTasks,queue:taskQueue};const saveTasks=()=>{if(!storePath)return;existsSync(dirname(storePath))||mkdirSync(dirname(storePath),{recursive:!0});const e=[];for(const[r,t]of preloadTasks.entries())e.push({url:r,...t});writeFileSync(storePath,JSON.stringify(e,null,2))},removeOldIfNeeded=()=>{if(!storePath)return;let e=preloadTasks.size-maxPreload;if(!(e<=0))for(const[r,t]of[...preloadTasks.entries()])if(preloadTasks.delete(r),[t.torrentPath,t.downloadPath].forEach((e=>{"string"===typeof e&&existsSync(e)&&rmSync(e,{recursive:!0})})),console.log("[Preload] Remove old task",r),e--,e<=0)return saveTasks()},queueTask=({url:e,path:r,origin:t,postTitle:o})=>{if(maxPreload<=0)return;if(taskQueue.find((r=>r.url===e)))return console.log("[Preload] Skip existed",e);if(taskQueue.length>=maxTask){const e=taskQueue.shift();if(e){const{url:r,path:t,origin:o,postTitle:s,torrent:a}=e;console.log("[Preload] Remove first old task from queue",r),preloadTasks.has(r)?a.destroy((()=>{})):a.destroy({destroyStore:!0},(()=>{previous.push({url:r,path:t,origin:o,postTitle:s})}))}}let s=!1;const a=preloadClient.add(e,{path:r,storeOpts:{postTitle:o||""},postTitle:o,strategy:"sequential"});taskQueue.push({url:e,path:r,origin:t,postTitle:o,torrent:a});const n=setTimeout((()=>{a.ready||a.destroyed||(console.log("[Preload] Failed to load task",t),ipcRenderer.send("preload-failed",t),a.destroy((()=>{const r=taskQueue.findIndex((r=>r.url===e));if(-1!==r){const[e]=taskQueue.splice(r,1);failures.find((r=>r.origin===e.origin))||failures.push(e)}})))}),maxWaitTime);return a.on("ready",(()=>{if(clearTimeout(n),!a.torrentFile||!a.infoHash)return;const o=resolve(dirname(r),`../torrents/${a.infoHash}.torrent`);existsSync(dirname(o))||mkdirSync(dirname(o),{recursive:!0}),existsSync(o)||writeFileSync(o,a.torrentFile),preloadTasks.has(e)||(preloadTasks.set(e,{downloadPath:r,torrentPath:o,origin:t,torrent:Object.assign(torrentToJson(a),{preloadStatus:1})}),saveTasks())})),a.on("download",(()=>{s||a.downloaded>downloadThreshold&&(s=!0,a.destroy((()=>{console.log("[Preload] Finish preloading",t),removeOldIfNeeded(),ipcRenderer.emit("preload-done",t);const r=taskQueue.findIndex((r=>r.url===e)),o=preloadTasks.get(e);if(o&&(o.torrent=Object.assign(torrentToJson(a),{preloadStatus:2}),saveTasks()),-1!==r&&(taskQueue.splice(r,1),taskQueue.length<maxTask&&previous.length)){const{url:e,path:r,origin:t,postTitle:o}=previous.shift();queueTask({url:e,path:r,origin:t,postTitle:o})}})))})),a};ipcRenderer.on("preload-restore",((e,r)=>{console.log("[Preload] Restore",r);try{const e=resolve(r,"preload-tasks.json"),t=new Date;t.setDate(t.getDate()-7);const o=t.valueOf();if(existsSync(e)){const r=JSON.parse(readFileSync(e));for(const e of r){if(!existsSync(e.torrentPath)||!existsSync(e.downloadPath)){existsSync(e.torrentPath)&&rmSync(e.torrentPath),existsSync(e.downloadPath)&&rmSync(e.downloadPath,{recursive:!0});continue}if(e.removed)continue;const{mtimeMs:r}=statSync(e.torrentPath);r<o?(rmSync(e.torrentPath),existsSync(e.downloadPath)&&rmSync(e.downloadPath,{recursive:!0})):e.torrent&&e.torrent.downloaded<downloadThreshold?(queueTask({url:e.url,origin:e.origin,path:e.downloadPath,postTitle:e.torrent.postTitle||e.torrent.name}),console.log("[Preload] Restart",e.url)):(console.log("[Preload] Restore",e.url),preloadTasks.set(e.url,e))}console.log(`[Preload] Restore ${r.length} tasks`)}storePath=e}catch(e){console.log(`Failed to load preloads from ${r}`,e)}})),ipcRenderer.on("preload-task",((e,{url:r,path:t,origin:o,postTitle:s})=>{preloadTasks.has(r)||(console.log("[Preload] Receive task",{url:r,path:t,origin:o,postTitle:s}),queueTask({url:r,path:t,origin:o,postTitle:s}))}));export default{loadCache(e,r){if(preloadTasks.has(e)){const{torrentPath:t,downloadPath:o,removed:s}=preloadTasks.get(e);return s?(console.log("Preload task is removed!"),t):(console.log("copy",o,r),cpSync(o,r,{recursive:!0}),setTimeout((()=>{rmSync(o,{recursive:!0}),preloadTasks.set(e,{torrentPath:t,removed:!0})}),5e3),t)}return null},enable(){maxPreload=40,localStorage.setItem("library-max-preload","40")},disable(){maxPreload=0,localStorage.setItem("library-max-preload","0"),removeOldIfNeeded(),taskQueue.splice(0),preloadTasks.clear()},preloadTasks:preloadTasks,taskQueue:taskQueue,failures:failures};